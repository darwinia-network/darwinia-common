type Relay Stuffs = Vec<Relay Stuff>

enum Relay Stuff<Header, MMRRoot> {
	Header(Header),
	MMRRoot(MMRRoot),
	Other(Vec<u8>),
}

struct Proposal {
	[proposed: <Vec<Relay Stuffs>]
		if extended proposal id is none (this proposal is a main proposal)
			the relay target that this proposal aim at
			the things that will be store on chain finally
			for ethereum (header, mmr root)
		else (this proposal is a sub-proposal which must extend from some)
			the things that chain required to perform the continuous verification AKA samples
			for ethereum (header)
	[bonds: Vec<(Account Id, Balance)>]
		the bonds of this proposal
	[extended proposal id: Option<(Game Id, Round, Index)>]
		game id, round and the index under the round point to a unique proposal AKA proposal id
	[verified: bool]
		the verification status of this proposal
}

fn propose (
	[relayer: Account Id]
		the account id AKA relay worker, relayer, proposer
	[proposed: Relay Stuffs]
		the things that will be store on chain finally
		for ethereum (header, mmr root)
	[proofs: Option<Vec<Proofs>>]
		the proofs to verify the relay (and samples) stuffs which can be ignore
		for ethereum (ehashproof, mmr proof)
)

fn complete proofs (
	[relayer: Account Id]
		the relay worker/relayer/proposer
	[proposal id: (Game Id, Round, Index)]
		game id, round and the index under the round point to a unique proposal AKA proposal id
	[proofs: Proofs]
		the proofs to verify the relay stuffs
		for ethereum (ehashproof, mmr_proof)
)

fn extend proposal (
	[relayer: Account Id]
		the relay worker/relayer/proposer
	[proposed: Vec<Relay Stuffs>]
		the samples that game required at the round that this proposal extend from
	[extended proposal id: (Game Id, Round, Index)]
		game id, round and the index under the round point to a unique proposal AKA proposal id
	[proofs: Option<Vec<Proofs>>]
		the proofs to verify the relay (and samples) stuffs which can be ignore
		for ethereum (ehashproof, mmr proof)
)

A propose a relay

B (challenger) have to propose a relay that ensure proposal's `proofs` is some

chain will deposit a event `Challenge(game id)`

A could complete the proofs within the challenge time if don't slash A
to prevent B challenge A too late that make A got slashed, because A don't have enough time to response (complete the proofs)
challenge time = propose time + complete proofs time
relayer can only make a proposal during the propose time
